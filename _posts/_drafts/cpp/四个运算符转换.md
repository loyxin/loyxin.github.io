# 四个运算符转换
1. dynamic_cast 
2. static_cast 
3. reinterpret_cast 
4. const_cast

## dynamic_cast<类型>(表达式)
该转换符用于将一个指向派生类的基类指针或引用转换为派生类的指针或引用，注意`dynamic_cast`转换符只能用于含有虚函数的类.
如果指向派生类的基类指针`base`想访问派生类`Derive`中的除虚函数之外的成员时就需要把该指针转换为指向派生类`Derive`的指针，以达到访问派生类D中特有的成员的目的
*dynamic_cast的注意事项：*
1. `dynamic_cast`转换符只能用于指针或者引用。 类型必须是类的指针、类的引用或者`void*`；
2. 如果` type-id` 是类指针类型，那么`expression`也必须是一个指针，如果 `type-id` 是一个引用，那么 `expression` 也必须是一个引用。
2. `dynamic_cast`转换符只能用于含有虚函数的类。


dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。
在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。可以成功的是一个子类转换成父类, 再转换成子类, 可以成功

## static_cast<类型>(表达式)
该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。

该操作符用于非多态类型的转换，任何标准转换都可以使用他，即`static_cast`可以把`int`转换为`double`，但不能把两个不相关的类对象进行转换，比如类A不能转换为一个不相关的类B类型。`static_cast`本质上是传统c语言强制转换的替代品。

## const_cast<类型>(表达式)
该操作符用于改变`const`和`volatile`，`const_cast`最常用的用途就是删除`const`属性，如果某个变量在大多数时候是常量，而在某个时候又是需要修改的，这时就可以使用`const_cast`操作符了。`const_cast`操作符不能改变类型的其他方面，他只能改变`const`或`volatile`，即`const_cast`不能把`int`改变为`double`，但可以把`const int`改变为`int`。`const_cast`只能用于指针或引用。

## reinterpret_cast<类型>(表达式)
该操作符用于将一种类型转换为另一种不同的类型，比如可以把一个整型转换为一个指针，或把一个指针转换为一个整型，因此使用该操作符的危险性较高，一般不应使用该操作符。

## 多态类型
```cpp
//A为非多态类型 
class A{
};
//B为多态类型
class B{ 
    public: virtual ~B(){}
};
//D为多态类型
class D: public A{
};
//E为非多态类型
class E : private A{
};
//F为多态类型
class F : private B{
}
```
## 横向转型
1. 子类向基类的向上转型(Up Cast)
2. 基类向子类的向下转型(Down Cast)
3. 横向转型(Cross Cast)


```cpp
#include <string>
#include <iostream>
using namespace std;
class Parents
{
public:
	Parents(string n="Parent"){ name = n;}
	virtual ~Parents(){}
	virtual void Speak()
	{cout << "\tI am " << name << ", I love my children." << endl;}
	void Work()
	{cout << "\tI am " << name <<", I need to work for my family." << endl;;}
protected:
	string name;
};

class Children : public Parents
{
public:
	Children(string n="Child"){name = n;}
	virtual ~Children(){}
	virtual void Speak()
	{cout << "\tI am " << name << ", I love my parents." << endl;}
	/*
	 **Children inherit Work() method from parents,
	 **it could be treated like part-time job.
	 */
	void Study()
	{cout << "\tI am " << name << ", I need to study for future." << endl;;}
private:
	//string name; //Inherit "name" member from Parents
};


int main() {
	/******* cast from child class to base class *******/
	cout << "dynamic_cast from child class to base class:" << endl;
	Children * daughter_d = new Children("Daughter who pretend to be my mother");
	daughter_d->Work();
	daughter_d->Study();
	daughter_d->Parents::Speak();
	daughter_d->Children::Speak();
	daughter_d->Speak();

	std::cout << "change" << '\n';
	
	Parents * mother_d = dynamic_cast<Parents*> (daughter_d); //right, cast with polymorphism
	mother_d->Speak();
	mother_d->Parents::Speak();
	mother_d->Work();
	//mother_d->Study(); //Error, no such method
	cout << endl;
	
	cout << "static_cast from child class to base class:" << endl;
	Children * son_s = new Children("Son who pretend to be my father");
	Parents * father_s = static_cast<Parents*> (son_s); //right, cast with polymorphism same
	father_s->Speak();
	father_s->Work();
	//father_s->Study(); //Error, no such method

	cout << endl;
	/******* cast back*******/
	cout << "use dynamic_cast to cast back from static_cast:" << endl;
	Children* child_s = dynamic_cast<Children*> (father_s);
	if (child_s)
	{
		child_s->Speak();
		child_s->Work();
	}
	else cout << "\t[null]" << endl;

	/******* cast from base class to child class *******/
	cout << "dynamic_cast from base class to child class:" << endl;
	Parents * father_d = new Parents("Father who pretend to be a my son");
	Children * son_d = dynamic_cast<Children*> (father_d); //no error, but  safe
	if (son_d)
	{
		son_d->Work();
		son_d->Study();
		son_d->Parents::Speak();
		son_d->Children::Speak();
		son_d->Speak();
	}
	else cout << "\t[null]" << endl;

	cout << "static_cast from base class to child class:" << endl;
	Parents * mother_s = new Parents("Mother who pretend to be a my daugher");
	Children * daughter_s = static_cast<Children*> (mother_s);  //no error, but not safe
	if (daughter_s)
	{
		daughter_s->Work();
		daughter_s->Study();
		daughter_s->Parents::Speak();
		daughter_s->Children::Speak();
		daughter_s->Speak();
	}
	else cout << "\t[null]" << endl;

	cout << endl;
}
```

output::
```
dynamic_cast from child class to base class://子类有所有的函数 现在是父类的指针
	I am Daughter who pretend to be my mother, I need to work for my family.
	I am Daughter who pretend to be my mother, I need to study for future.
	I am Daughter who pretend to be my mother, I love my children.
	I am Daughter who pretend to be my mother, I love my parents.
	I am Daughter who pretend to be my mother, I love my parents.
change
	I am Daughter who pretend to be my mother, I love my parents.//所以调用子类的, 因为带有虚表 指针记录偏移量
	I am Daughter who pretend to be my mother, I love my children.
	I am Daughter who pretend to be my mother, I need to work for my family.
static_cast from child class to base class:
	I am Son who pretend to be my father, I love my parents.
	I am Son who pretend to be my father, I need to work for my family.

use dynamic_cast to cast back from static_cast://把 上面的static 变回了
	I am Son who pretend to be my father, I love my parents.
	I am Son who pretend to be my father, I need to work for my family.
dynamic_cast from base class to child class://新的对象 父类 不可以
	[null]
static_cast from base class to child class://新的对象 父类 可以
	I am Mother who pretend to be a my daugher, I need to work for my family.
	I am Mother who pretend to be a my daugher, I need to study for future.
	I am Mother who pretend to be a my daugher, I love my children.
	I am Mother who pretend to be a my daugher, I love my parents.
	I am Mother who pretend to be a my daugher, I love my children.//因为带有虚表 指针记录偏移量
```
