C++使用虚拟继承（Virtual Inheritance），解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。

虚继承 会有一个指向父类的指针 虚表 但是编译器会优化

```cpp
#include<iostream>
using namespace std;
class a
{
    virtual void func(){}
};
class b:public virtual a
{
    virtual void foo(){}
};

class a1
{
    virtual void func(){}
};
class b1 : public a1
{
    virtual void foo(){}
};
class a2
{
    virtual void func(){}
    char x;
};
class b2:public virtual a2
{
    virtual void foo(){}
};

class a3 
{
    virtual void func(){}
    char x;
};

class b3:public a3
{
    virtual void foo(){}
};

int main()
{
    a a;
    b b;
    a1 a1;
    b1 b1;
    a2 a2;
    a3 a3;
    b2 b2;
    b3 b3;
    cout<<sizeof(a)<<" "<<sizeof(a1)<<" "<<sizeof(a2)<<"  "<<sizeof(a3)<<endl;
    cout<<sizeof(b)<<" " <<sizeof(b1)<<" "<<sizeof(b2)<<" "<<sizeof(b3)<<endl;
    return 0;
}

```

output:

```
8 8 16  16
8 8 24 16
```



```cpp
#include<iostream>
using namespace std;
class Base
{
public:
    Base()
    {cout << "<<< base constructor" << endl;}
    virtual ~Base()
    {cout << "<<< base destructor" << endl;}
    virtual void x()
    {cout<<"base"<<endl;}
};

class Derived : public Base
{
public:
    Derived():Base()
    {cout << "<<< derived constructor" << endl;}
    ~Derived()
    {cout << "<<< derived destructor" << endl;}
    void x()
    {cout<<"derived"<<endl;}
};

int main(int argc, char* argv[])
{
    Base* derived = new Derived();
    derived->x();
    delete derived;
    cout << endl;
    return 0;
}
```

output:
```
<<< base constructor
<<< derived constructor
derived
<<< derived destructor
<<< base destructor
```

虚继承改变了`x()`的位置,指针不符合也能正确的表达

继承重写把父类的虚函数隐藏了,但是还是有,肯定能访问

调用了父类构建函数,但是没有调用子类析构函数,因为是父类指针

如果写成 或者`virtual`没有
```
derived->Base::x();
```
output:
```
base
```



