---
layout: post
title:  "geant4 代码编写要点"
categories: geant4
tags:  geant4 模拟
author: loyxin
mathjax: true
---
* content
{:toc}

先大概介绍各个文件的作用，理解每个文件应该做什么，理解到 geant4 的框架是什么样后，就明白接下来就是参考资料，写代码了

每个文件基本要写库文件(.hh)和源文件(.cc)，分别放在**include**和**src**文件夹

geant4 要告诉**探测器的结构**(DetectorConstruct 要做的事)和设计的**物理过程**(Physical list 要做的事)是怎么样的，有了这些就可以运行了，但是geant4的数据是保存在内存里面的，所以要通过 action 类把这些信息重新获取出来

先介绍主文件
## main.cc
必须新建三个强制类
- DetectorConstruction
- PhylicsList
- ActionInitialization

![](http://ow3kig4i4.bkt.clouddn.com/blog/pic/geant4/Mandatory.png?imageView/2/w/600)

交给`runManager`管理，main 函数也可以新建宏文件调用的对象 **batch mode** ，和`terminal`控制的对象 可视化界面和 **Interactive mode**, 还有纯代码模式就是代码写什么，直接模拟什么，不用调用 `G4UImanager` 和 ` G4VisManager G4UIExecutive`

```cpp
// 宏文件调用
G4UImanager* UImanager = G4UImanager::GetUIpointer();
G4String command = "/control/execute ";
G4String fileName = argv[1];
UImanager->ApplyCommand(command + fileName);

// G4UIExecutive 类似 G4UIsession Interactive mode 可视化界面
//ifdef G4VIS_USE
  G4VisManager* visManager = new G4VisExecutive("quiet");
  visManager->Initialize();
//endif  
G4UIExecutive* ui = new G4UIExecutive(argc, argv);
ui->SessionStart();

delete visManager;
delete ui;
```

### Detector construction
- Define the geometry of your model (Construct()函数)
 * All **materials**
 * All **volumes & placements**
- (Optionally) add fields (ConstructSDandField()函数)
- (Optionally) define volumes for read-out (sensitive detectors)(ConstructSDandField()函数)

```cpp
class G4VUserDetectorConstruction
{
public:
G4VUserDetectorConstruction();
virtual ~G4VUserDetectorConstruction();
public:
virtual G4VPhysicalVolume* Construct() = 0;
virtual void ConstructSDandField();

}
```

只有 `Construct()` 是纯虚函数，所以 `Construct()` 必须要重写，不过这个也是很显然的事情，不搭建探测器怎么模拟呢？

这个文件主要做的事情是就是搭建探测器, 探测器的代码的步骤写 **材料**$\rightarrow$**形状 logicalVolume**$\rightarrow$**PhysicalVolume**

### Physics list

- Define all **necessary particles** (ConstructParticle() 函数)
- Define all necessary **processes** and **assign** them to proper particles (ConstructProcess() 函数)
- Define particles production **threshold** (in terms of range) (SetCuts()函数)



```cpp
class G4VUserPhysicsList
{
public:
G4VUserPhysicsList();
virtual ~G4VUserPhysicsList();
public:
virtual void ConstructParticle() = 0;
virtual void ConstructProcess() = 0;
virtual void SetCuts();
// ...
}
```

physicsList 有两个纯虚函数，粒子和过程。 粒子这个很简单，实在不行把所有的粒子都注册，但是此时是没有物理过程，就是说你发射一个粒子，某个位置产生这个粒子，但是计算机没有模型让它动起来，简单的说有了初始条件却没有微分方程，所以要针对**每一个粒子**注册物理过程，所有粒子的物理过程都写好了，但是现实世界的过程是复杂的，没有必要对**每一个能量**的粒子都要模拟，比如说我们测量高能物理过程，不需要测量低能的，或者低能的影响很小，这时候就没有必要模拟低能，白白浪费计算机资源，所以就要设置阈值 `SetCuts()` 。

## Primary generator action

所有的 action 类都应该在 ActionInitialization 类初始化

- Define the source of simulated particles
-  kinematic properties
-  additional information

位置信息必须放在 GeneratePrimaries(G4Event* ) 函数中

```cpp
class G4VUserPrimaryGeneratorAction
{
public:
G4VUserPrimaryGeneratorAction();
virtual ~G4VUserPrimaryGeneratorAction();
public:
virtual void GeneratePrimaries(G4Event* anEvent) = 0;
// ...
}
```

这个没有什么好说的，看几个 `example` 下的例子就知道怎么写了

## 强制类的成员函数

### G4VUserDetectorConstruction
```cpp
public:
    G4VUserDetectorConstruction();
    virtual ~G4VUserDetectorConstruction();

public:
    virtual G4VPhysicalVolume* Construct() = 0;

    virtual void ConstructSDandField();

    virtual void CloneSD();
    virtual void CloneF();  
public:
    void RegisterParallelWorld(G4VUserParallelWorld*);

public:
    G4int ConstructParallelGeometries();
    void ConstructParallelSD();

private:
    std::vector<G4VUserParallelWorld*> parallelWorld;

public:
    G4int GetNumberOfParallelWorld() const;
    G4VUserParallelWorld* GetParallelWorld(G4int i) const;

protected:
    void SetSensitiveDetector(const G4String& logVolName,
                G4VSensitiveDetector* aSD,G4bool multi=false);
    void SetSensitiveDetector(G4LogicalVolume* logVol,
                G4VSensitiveDetector* aSD);
};
```

### G4VUserDetectorConstruction
```cpp
class G4VUserPhysicsList
{
  public:
    G4VUserPhysicsList();
    virtual ~G4VUserPhysicsList();
  public: 
    void Construct();
  protected: 
   virtual void ConstructProcess() = 0;
  protected: 
   void AddTransportation();// 这个记得一定要加在 ConstructProcess() 函数中，要不然粒子无法运动
  G4bool RegisterProcess(G4VProcess*            process,
			  G4ParticleDefinition*  particle);//用这个注册过程
  public:
   void UseCoupledTransportation(G4bool vl=true);
  public:
   virtual void SetCuts(); //会调用默认的 SetDefaultCutValue
  public:  
   void     SetDefaultCutValue(G4double newCutValue);
   G4double GetDefaultCutValue() const;
  public: 
    void BuildPhysicsTable();    
    void PreparePhysicsTable(G4ParticleDefinition* );    
    void BuildPhysicsTable(G4ParticleDefinition* );    
    G4bool  StorePhysicsTable(const G4String& directory = ".");
    G4bool  IsPhysicsTableRetrieved() const;
    G4bool  IsStoredInAscii() const;
    const G4String& GetPhysicsTableDirectory() const;
    void    SetPhysicsTableRetrieved(const G4String& directory = "");
    void    SetStoredInAscii();
    void    ResetPhysicsTableRetrieved();
    void    ResetStoredInAscii();
  public:
    void DumpList() const;
  public: 
    void DumpCutValuesTable(G4int flag =1);
    void DumpCutValuesTableIfRequested();
  public: 
    void  SetVerboseLevel(G4int value);
    G4int GetVerboseLevel() const;
  public: 
   void SetCutsWithDefault();   
   void SetCutValue(G4double aCut, const G4String& pname); 
   G4double GetCutValue(const G4String& pname) const; 
   void SetCutValue(G4double aCut, const G4String& pname, const G4String& rname); 
   void SetParticleCuts(G4double cut,G4ParticleDefinition* particle,G4Region* region=0);
  void SetParticleCuts( G4double cut, const G4String& particleName, G4Region* region=0);
   void SetCutsForRegion(G4double aCut, const G4String& rname);
   void ResetCuts();
  public:   
   void SetApplyCuts(G4bool value, const G4String& name); 
   G4bool GetApplyCuts(const G4String& name) const; 
  protected:  
    void BuildIntegralPhysicsTable(G4VProcess* ,G4ParticleDefinition*  );   
  protected: 
    virtual void  RetrievePhysicsTable(G4ParticleDefinition* ,	
				       const G4String& directory, 
				       G4bool          ascii = false);
  protected: 
    void InitializeProcessManager();
  public: 
    void RemoveProcessManager();
  public: 
    void AddProcessManager(G4ParticleDefinition* newParticle,
			   G4ProcessManager*    newManager = 0 );
  public:
    void CheckParticleList();
    void DisableCheckParticleList();
  protected:
   G4ParticleTable* theParticleTable;
  protected:
   G4int verboseLevel;
  protected:
   G4double defaultCutValue;
   G4bool   isSetDefaultCutValue;
  protected:
   G4ProductionCutsTable* fCutsTable;
   G4bool fRetrievePhysicsTable;  
   G4bool fStoredInAscii;
   G4bool fIsCheckedForRetrievePhysicsTable;
   G4bool fIsRestoredCutValues;
   G4String directoryPhysicsTable;   
   G4bool fDisableCheckParticleList; 
  private:
   enum { FixedStringLengthForStore = 32 }; 
  protected:
    G4int g4vuplInstanceID;
    G4RUN_DLL static G4VUPLManager subInstanceManager;
    G4ParticleTable::G4PTblDicIterator* GetParticleIterator() const;
  public:
    inline G4int GetInstanceID() const;
    static const G4VUPLManager& GetSubInstanceManager();
    void InitializeWorker();
};
  
```
