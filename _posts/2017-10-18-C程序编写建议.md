---
layout: post
title:  "C程序编写建议"
categories: C
tags:  C
author: loyxin
mathjax: true
---

* content
{:toc}

## 防止整数类型溢出

＞ 显式声明 `char` 类型

```c
char c = 150;
int i = 900;
int ans = i/c;
```
`ans` 的值会因为`c`被不同的编译器确定为`signed char`或者`unsigned char` 的一种，总之大于127的`char`类型可能会溢出

> `size_t` 类型
不同的平台定义不一样，但是一般是`unsigned`型的，`sizeof`返回类型为`size_t`

**比较无符号类型**的时候,比如

```
int i = -1;
int array[] = {....}
if( i <= sizeof(array))
```

会有隐式变换有符号变成无符号的，从而变成很大的数，所以做比较的时候要变成同一类型的，最好是一样的类型，免得**做循环的时候，在判断条件的时候，循环变量会溢出**

## 浮点数
> 避免浮点数使用`==`操作符进行判断
> 避免浮点数作为循环变量

## 数据转换
`int`　和 `long`　运算，`int`　会变成　`long`　参与运算，所有浮点运算都是双精度的，　`char`和`short`的参与运算，会先变成`int`类型
> 整型，浮点数转换，先进行范围检查，在检查值

## typedef

> 陷阱

```
#define //替换
typedef char* PCHAR;
const PCHAR//的类型是　char* const 指针是常量的
```

所以为指针声明`typedef`，应该在最终的`typedef`名称中加一个`const`
`typedef` 是别名

## 提高除法运算
加法减法最快，乘法比除法快4-6倍，除法要２０－１００周期

用倒数求除法，用牛顿法求倒数

## if语句

先处理正常情况，再处理异常情况

判断条件避免布尔类型与０１比较　整型与０比较　指针和`NULL`比较

```
if(i == 0)
if(i != 0)\\ int i;
if(i)
if(!i)\\bool i;
```

## 函数

- 避免写`static`局部变量，返回值也不要是静态变量
- 参量使用`const`
- 检查参数的有效性和安全和返回值的有效性和安全
- 减少递归

## 结构体
结构体会因为对齐，结构体大小会不等于数据成员的长度之和，

(结构体的大小，知乎)[https://www.zhihu.com/question/28958350]

> 避免在结构体之间执行逐字节比较

因为对齐产生的字节未初始化，

```c
typedef struct
{
    char c;
    int i;
    char buf[10];
}Buffer;

unsigned int Func(const Buffer* buf1,const Buffer* buf2){
    if(!memcmp(buf1,buf2,sizeof(Buffer))){
        return 1;
    }
    else{
        return 0;
    }
}
// change to 
unsigned int Func(const Buffer* buf1,const Buffer* buf2){
    if(buf1->c!=buf2->c)
    {
        return 0;
    }
    .....
    return 0;
}
```

## 预处理

> 宏定义是宏替换

```c
#define S(x) x*x
s(x+2) //means
x+2＊x+2
```
所以要加括号

```
#define S(x) (x)*(x)
```

在传入自增自减的时候可能会执行两次

内联函数减少了函数的调用时间，只有当内联函数无法展开的，或者以地址出现，编译器才会生成单独的代码